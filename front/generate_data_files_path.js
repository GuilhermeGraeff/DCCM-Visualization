/*

Este script e responsável por mapear os arquivos binários referentes às simulações, 
localiza sistemas, réplicas e diferentes tamanhos de fatias do método

Ele é rodado de forma manual utilizando o node ('node generate_data_files_path.js'), 
este deve ser rodado após a obtenção dos dados que é tarefa do 'back'.

*/
const fs = require('fs');
const path = require('path');

const dataDir = path.join(__dirname, 'public/data'); 
const outputFilePath = path.join(__dirname, 'js', 'simulation_data_files_path.js'); 

const simulationData = {};


const extractNumber = (filename) => {
    const match = filename.match(/_(\d+)\.bin$/);
    return match ? parseInt(match[1], 10) : 0;
};


try {
    // Localizar e filtrar as pastas* dos sistemas na pasta de dados
    const simulationFolders = fs.readdirSync(dataDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

    // Para cada pasta* simulação
    for (const simFolder of simulationFolders) {
        const dataDirReplica = path.join(dataDir, simFolder);
        const replicaFolders = fs.readdirSync(dataDirReplica, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name);

        simulationData[simFolder] = {};

        // Para cada pasta* de réplica
        for (const replicaFolder of replicaFolders) {
            const replicaPath = path.join(dataDirReplica, replicaFolder);
            
            const replicaFiles = fs.readdirSync(replicaPath)
                .filter(file => path.extname(file).toLowerCase() === '.bin');

            simulationData[simFolder][replicaFolder] = {};

            // Escreve neste dicionário os caminhos utilizado para armazenar os arquivos binários
            for (const replicaFile of replicaFiles) {
                const webPath = `/data/${simFolder}/${replicaFolder}/${replicaFile}`;
                simulationData[simFolder][replicaFolder][replicaFile] = webPath;
            }
        }
    }

    // Reorganiza o dicionário para manter a ordem crescente de tamanho de fatia
    for (const systemKey in simulationData) {
        const replicas = simulationData[systemKey];

        for (const replicaKey in replicas) {
            const files = replicas[replicaKey];

            const sortedKeys = Object.keys(files).sort((a, b) => {
                const numA = extractNumber(a);
                const numB = extractNumber(b);
                return numA - numB;
            });

            const sortedFiles = {};
            for (const key of sortedKeys) {
                sortedFiles[key] = files[key];
            }

            simulationData[systemKey][replicaKey] = sortedFiles;
        }
    }


    const fileContent = `// This file is auto-generated by generate_data_files_path.js. Do not edit manually.\n\nconst simulationData = ${JSON.stringify(simulationData, null, 4)};\n\nexport default simulationData;\n`;

    fs.writeFileSync(outputFilePath, fileContent);

    console.log(`Success: ${outputFilePath}`);

} catch (error) {
    console.error("Error generating file paths: ", error);
}